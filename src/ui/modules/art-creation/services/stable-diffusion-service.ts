import { divide, multiply } from 'lodash';

import { getImageProtocolUrl } from '../../../../app/main/img-protocol';
import { Autowired, Bean } from '../../../../common/ioc-manager';
import { getBase64Image } from '../../../utils/utils';
import { ArtCreationController } from '../art-creation-controller';
import {
    ArtCreationStore,
    IEditTableDataItem,
    IImage,
} from '../art-creation-store';
import { GlobalSettingService } from './global-setting-service';
import { ipcRender } from './ipc-ui-service';
import { log } from 'console';

@Bean
export class StableDiffusionService {
    @Autowired
    private artCreationController!: ArtCreationController;

    @Autowired
    private globalSettingService!: GlobalSettingService;

    @Autowired
    private artCreationStore!: ArtCreationStore;

    public textToImage(
        data: IEditTableDataItem[],
        currentIndex: number,
        toHigh: boolean = false,
    ) {
        return this.progressBatchTextToImage(data, currentIndex, toHigh);
    }

    /**
     * to generate image by stable diffusion webui apis
     *
     * @param {IEditTableDataItem[]} data - an array of IEditTableDataItem objects
     * @param {number} currentIndex - the current index in the data array
     * @param {boolean} toHigh - flag indicating whether to set image to high resolution
     * @return {Promise<IEditTableDataItem[]>} - the modified data array
     */
    private async progressBatchTextToImage(
        data: IEditTableDataItem[],
        currentIndex: number,
        toHigh: boolean = false,
    ) {
        if (currentIndex >= data.length) {
            return data;
        }
        const nextEditTableDataItem = data[currentIndex];
        const { prompts } = nextEditTableDataItem;
        if (!prompts) {
            return data;
        }

        if (data?.length > 1) {
            this.artCreationStore.setStore({
                progressProps: {
                    percent: Math.floor(
                        multiply(divide(currentIndex + 1, data.length), 100),
                    ),
                },
            });
        }

        const nextImage: IImage = {
            ...nextEditTableDataItem.image,
            loading: true,
        };
        nextEditTableDataItem.image = nextImage;
        if (toHigh && nextEditTableDataItem.sdGenImageData) {
            this.artCreationController.updateView(data);
            this.updateViewImageProgress(data, nextEditTableDataItem);
            // const hrTextToImageData = await this.hrTextToImage(
            //     nextEditTableDataItem.sdGenImageData,
            // );
            // const image = hrTextToImageData.images[0];
            const extraSingleImageData = await this.extraSingleImage({
                image: nextEditTableDataItem.image.src,
            });
            const hrImage = extraSingleImageData.image;
            nextImage.isHrImage = true;
            const { path } = await this.saveImageToFile(
                nextEditTableDataItem,
                hrImage,
            );
            nextImage.src = getImageProtocolUrl(path);
            nextImage.path = path;
        } else if (!toHigh) {
            this.artCreationController.updateView(data);
            this.updateViewImageProgress(data, nextEditTableDataItem);
            const ordTextToImageData = await this.ordTextToImage(
                nextEditTableDataItem,
            );
            const textToImageInfo = JSON.parse(ordTextToImageData.info);
            nextImage.src = getBase64Image(ordTextToImageData.images[0]);
            nextImage.isHrImage = false;
            nextEditTableDataItem.sdGenImageData = textToImageInfo;
        }
        nextImage.loading = false;
        nextEditTableDataItem.image = nextImage;
        nextEditTableDataItem.loading = false;
        this.artCreationController.updateView(data);
        await this.progressBatchTextToImage(data, currentIndex + 1, toHigh);
    }

    private updateViewImageProgress(
        data: IEditTableDataItem[],
        currentItem: IEditTableDataItem,
    ) {
        const timer = setInterval(async () => {
            const textToImageProgress = await ipcRender.invoke(
                'getTextToImageProgress',
            );
            const currentImage = textToImageProgress['current_image'];
            if (currentImage) {
                // todo 可能存在内存泄露
                currentItem.image.src = getBase64Image(currentImage);
                this.artCreationController.updateView(data);
            }
            clearInterval(timer);
        }, 1000);
    }

    /**
     * Generates an image from a given text prompt generated by stable diffusion webui apis
     *
     * @param {Object} options - The options for generating the image.
     * @param {string} options.prompt - The text prompt to generate the image from.
     * @return {Promise<Image>} A promise that resolves to the generated image.
     */
    private ordTextToImage(options: IEditTableDataItem) {
        const { prompts, negativePrompts, loras } = options;
        const loraPrompts = this.globalSettingService.getLoraPrompts(loras);
        const mergedSdPrompts = [prompts, loraPrompts].filter(Boolean).join();
        const textToImageOptions = {
            prompt: mergedSdPrompts,
            negative_prompt: negativePrompts || '',
            steps: 28,
            width: 1024,
            height: 1024,
            sampler_name: 'DPM++ 2M',
        };
        return this.runTextToImage(textToImageOptions);
    }

    private runTextToImage(textToImageOptions: any) {
        return ipcRender.invoke('textToImage', textToImageOptions);
    }

    private hrTextToImage(sdImageInfo: any) {
        const toHighTextToImageOptions = {
            ...sdImageInfo,
            hr_scale: 2,
            enable_hr: true,
            hr_height: 1024,
            hr_width: 1024,
            width: 512,
            height: 512,
            steps: 28,
            denoising_strength: 0.6,
            seed_resize_from_h: 512,
            seed_resize_from_w: 512,
            hr_prompt: sdImageInfo.prompt,
            hr_negative_prompt: sdImageInfo['negative_prompt'] || '',
        };
        return this.runTextToImage(toHighTextToImageOptions);
    }

    private saveImageToFile = (
        item: IEditTableDataItem,
        imageBase64: string,
    ) => {
        const fileName = `img-${item.id}.png`;
        return ipcRender.invoke('saveImageToFile', { fileName, imageBase64 });
    };

    private extraSingleImage(options: { image: string }) {
        const { image } = options;
        const extraSingleImageOptions = {
            show_extras_results: true,
            upscaling_resize: 2,
            upscaling_resize_w: 1024,
            upscaling_resize_h: 1024,
            upscaling_crop: true,
            upscaler_1: 'R-ESRGAN 4x+ Anime6B',
            upscaler_2: 'None',
            image: image,
        };
        return ipcRender.invoke('extraSingleImage', extraSingleImageOptions);
    }
}
